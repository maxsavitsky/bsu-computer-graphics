# Лабораторная работа №2

**Вариант 8** (в подгруппе я седьмой, но по ошибке реализовал восьмой вариант):
1.  **Глобальная пороговая обработка** (2 метода на выбор).
2.  **Реализация высокочастотных фильтров** (увеличение резкости).

## Структура проекта

```
lab02/
├── main.py            # Основной файл приложения (Python/Streamlit)
├── test_images/           # База изображений для тестирования
└── README.md              # Данный отчет
```

## Теоретическая часть

### 1. Глобальная пороговая обработка (Бинаризация)

**Цель:** Преобразовать полутоновое (grayscale) изображение в бинарное (черно-белое), где каждый пиксель может иметь только два значения: 0 (черный) или 255 (белый). Этот метод является простейшей формой сегментации изображения.

**Основной принцип:** Выбирается одно значение яркости, называемое глобальным порогом `T`. Каждый пиксель исходного изображения сравнивается с этим порогом: белый, если яркость пикселя > `T`, 0 в противном.

Основная сложность заключается в выборе этого порога `T`. В работе реализовано два подхода.

#### 1.1 Метод 1: Ручной порог

**Алгоритм:** Значение порога `T` задается пользователем вручную в диапазоне [0, 255]. Это самый прямой метод бинаризации.

**Преимущества:**
*   **Простота реализации**.
*   **Полный контроль** над результатом для достижения желаемого визуального эффекта.

**Недостатки:**
*   **Неавтоматизирован:** Требует ручной подстройки для каждого изображения.
*   **Чувствительность к условиям освещения:** На изображениях с неравномерным освещением (тени, градиенты) не существует единого порога `T`, который бы корректно обработал всё изображение.

#### 1.2 Метод 2: Метод Оцу

**Алгоритм:** Метод Оцу — это алгоритм автоматического подбора оптимального глобального порога.

**Ключевая идея:** Метод предполагает, что гистограмма яркостей изображения имеет два пика, соответствуя объектам и фону. Задача алгоритма — найти такой порог `T` между этими пиками, который наилучшим образом разделяет пиксели на два класса.

**Критерий оптимальности:** "Лучшим" считается тот порог, который максимизирует межклассовую дисперсию. Алгоритм ищет такое разделение на две группы, при котором эти группы максимально отличаются друг от друга, а пиксели внутри каждой группы, наоборот, максимально похожи.

**Процесс работы:**
1.  Строится гистограмма яркостей изображения.
2.  Итеративно перебираются все возможные пороги `t` от 0 до 255.
3.  Для каждого `t` пиксели делятся на два класса: Класс 1 (яркости [0...t]) и Класс 2 (яркости [t+1...255]).
4.  Вычисляется межклассовая дисперсия по формуле: `σ²(t) = w₁ * w₂ * (μ₁ -μ₂)²`, где `w` — веса классов (доли пикселей), `μ` — средние яркости классов.
5.  Порог `T`, при котором значение `σ²(t)` было максимальным, и выбирается в качестве оптимального.

### 2. Увеличение резкости (Нерезкое маскирование)

Это классический метод высокочастотной фильтрации, повышающий четкость изображения.

**Алгоритм:**
1.  **Размытие:** Создается размытая копия `Blurred` оригинального изображения с помощью фильтра Гаусса. Этот фильтр заменяет каждый пиксель взвешенным средним его окружения, где соседи ближе к центру имеют больший вес. На выходе получается НЧ-копия изображения.

2.  **Создание "маски":** Размытая копия вычитается из оригинала: `Mask = Original - Blurred`. Результат этой операции — изображение, содержащее только ВЧ-компоненты.

3.  **Применение маски:** Маска, умноженная на коэффициент "силы" (`amount`), добавляется к оригинальному изображению: `Sharpened = Original + amount * Mask`.

**Параметры алгоритма:**
*   **Радиус (Radius):** Определяет размер ядра Гауссова размытия и степень размытия.
*   **Сила (Amount):** Коэффициент, который определяет, насколько сильно будут усилены детали.

**Побочные эффекты:**
*   **Усиление шума:** Алгоритм не отличает "полезные" ВЧ-детали от "бесполезных" (шум), усиливая и то, и другое.

## Реализация (Python/Streamlit)

### `main.py`

Весь код реализован в одном файле с использованием фреймворка Streamlit.

**Библиотеки:**
- `streamlit` для создания интерактивного веб-интерфейса.
- `opencv-python-headless` для всех операций по обработке изображений.
- `numpy` для работы с массивами пикселей.
- `PIL (Pillow)` для удобного преобразования форматов изображений.

**Основные функции:**
*   `apply_threshold(image, threshold_value, method_otsu)`:
    - Конвертирует изображение в оттенки серого с помощью `cv2.cvtColor`.
    - Выбирает флаги для `cv2.threshold`: `cv2.THRESH_BINARY` для ручного режима и `cv2.THRESH_BINARY | cv2.THRESH_OTSU` для автоматического.
    - Возвращает бинарное изображение и использованное значение порога.

*   `apply_unsharp_masking(image, radius, amount)`:
    - Применяет размытие Гаусса с помощью `cv2.GaussianBlur`, используя заданный радиус.
    - Реализует формулу нерезкого маскирования с помощью одной функции `cv2.addWeighted`, которая эффективно вычисляет: `(1 + amount) * Original - amount * Blurred`.

**Интерфейс приложения (`Streamlit`):**
- **Боковая панель:** Содержит все элементы управления.
    - `st.file_uploader` для загрузки изображения.
    - `st.radio` для выбора метода пороговой обработки.
    - `st.slider` для настройки порога, силы и радиуса.
    - `st.button` для применения фильтров.
- **Основная область:**
    - `st.columns` для отображения изображений "Оригинал" и "Результат" бок о бок.
    - `st.image` для вывода изображений.
    - `st.download_button` для сохранения обработанного файла.

## Запуск

1. Установить зависимости:
   ```bash
   pip install streamlit opencv-python-headless numpy Pillow
   ```
2. Запустить приложение из терминала:
   ```bash
   streamlit run main.py
   ```
3. Открыть в браузере предоставленный локальный адрес (`http://localhost:8501`).

## Выводы

1.  **Реализованы методы** глобальной пороговой обработки (ручной и автоматический по методу Оцу) и метод увеличения резкости (нерезкое маскирование).
2.  Продемонстрированы преимущества и недостатки каждого алгоритма на специально подобранных тестовых изображениях.
3.  Метод Оцу эффективен только для бимодальных гистограмм и чувствителен к неравномерному освещению.
4.  Нерезкое маскирование эффективно повышает резкость, но также усиливает и существующий шум.
