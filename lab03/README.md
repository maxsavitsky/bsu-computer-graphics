# Лабораторная работа №3: Базовые растровые алгоритмы

## Задание

Реализовать приложение, иллюстрирующее работу базовых алгоритмов растеризации отрезков и окружностей:
1.  **Пошаговый алгоритм**
2.  **Алгоритм ЦДА** (Digital Differential Analyzer)
3.  **Алгоритм Брезенхема** для линий
4.  **Алгоритм Брезенхема** для окружностей

**Дополнительно**: В рамках работы также реализованы:
*   Алгоритм **Кастла-Питвея** для растеризации отрезков.
*   Алгоритм **Ву** для сглаживания линий.

## Теоретическая часть

### 1. Пошаговый алгоритм

**Принцип**: Наиболее очевидный метод, основанный на прямом использовании уравнения прямой `y = mx + b`. Алгоритм итерируется по доминирующей оси (оси с большей протяженностью отрезка) и для каждого шага вычисляет координату по другой оси.

**Алгоритм** (для доминирующей оси X):
```
m = (y1 - y0) / (x1 - x0)
b = y0 - m * x0

для x от x0 до x1:
    y = round(m * x + b)
    установить_пиксель(x, y)
```
**Недостаток**: Использование медленных операций с плавающей точкой (умножение, сложение) и округления на каждом шаге.

### 2. Алгоритм ЦДА (Digital Differential Analyzer)

**Принцип**: Усовершенствование пошагового алгоритма, заменяющее умножение в цикле на инкрементное сложение.

**Алгоритм**:
```
dx = x1 - x0
dy = y1 - y0
steps = max(|dx|, |dy|)

x_inc = dx / steps
y_inc = dy / steps

x = x0, y = y0
для i от 0 до steps:
    установить_пиксель(round(x), round(y))
    x += x_inc
    y += y_inc
```

**Преимущество**: Быстрее пошагового за счёт избавления от умножения внутри цикла.
**Недостаток**: По-прежнему использует арифметику с плавающей точкой.

### 3. Алгоритм Брезенхема (линия)

**Принцип**: Высокоэффективный алгоритм, использующий только целочисленную арифметику. На каждом шаге принимается решение о смещении по второй оси на основе накопленной "ошибки" — целочисленного параметра, показывающего отклонение растровой линии от идеальной.

**Алгоритм** (целочисленный, для |slope| ≤ 1):
```
dx = |x1 - x0|
dy = |y1 - y0|
error = 2 * dy - dx

для x от x0 до x1:
    установить_пиксель(x, y)
    если error >= 0:
        y += 1
        error -= 2 * dx
    error += 2 * dy
```

**Преимущество**: Самый быстрый алгоритм для растеризации линий благодаря отсутствию операций с плавающей точкой и делений.

### 4. Алгоритм Брезенхема (окружность)

**Принцип**: Основан на 8-кратной симметрии окружности. Алгоритм вычисляет пиксели только для jednego октанта (дуги в 45°), а координаты точек для остальных 7 октантов получаются путём симметричного отражения.

**Алгоритм**:
```
x = 0, y = radius
d = 3 - 2 * radius  // Начальный параметр решения

пока x ≤ y:
    установить_8_симметричных_точек(xc, yc, x, y)
    если d < 0:
        d += 4 * x + 6
    иначе:
        d += 4 * (x - y) + 10
        y -= 1
    x += 1
```

### 5. Алгоритм Ву (дополнительно)

**Принцип**: Антиалиасинг (сглаживание). Вместо выбора одного пикселя, алгоритм закрашивает два соседних пикселя с разной интенсивностью (прозрачностью), обратно пропорциональной их расстоянию до идеальной линии.

**Алгоритм**:
```
# Для каждого шага по доминирующей оси
y_ideal = ... // точное значение y
y_int = int(y_ideal)
y_frac = frac(y_ideal) // дробная часть

// Интенсивность обратно пропорциональна расстоянию
установить_пиксель(x, y_int, 1 - y_frac)
установить_пиксель(x, y_int + 1, y_frac)
```

### 6. Алгоритм Кастла-Питвея (дополнительно)

**Принцип**: Основан на идее, схожей с алгоритмом Евклида для нахождения НОД. Алгоритм кодирует растровую линию как последовательность прямых (`s`) и диагональных (`d`) шагов, которую затем рекурсивно генерирует.

**Алгоритм**:
```
// Преобразовать отрезок (0,0)->(a,b)
y_c = b, x_c = a - b
m1 = "s", m2 = "d"

пока x_c != y_c:
    если x_c > y_c:
        x_c -= y_c
        m2 = m1 + m2
    иначе:
        y_c -= x_c
        m1 = m2 + m1

результирующая_строка = (m2 + m1) * x_c
```
**Недостаток**: Использование операций со строками делает его менее эффективным, чем алгоритм Брезенхема.

## Производительность

### Бенчмарки

Измерения проводились в рамках работающего Streamlit-приложения. Для получения стабильных результатов, можно было бы провести многократные замеры и усреднить значения, но для целей демонстрации достаточно данных одного прогона.

**Тестовые данные**:
*   Линия: `(2, 3) -> (150, 80)`
*   Окружность: центр `(10, 10)`, радиус `70`

**Результаты** (примерные, могут незначительно меняться от запуска к запуску):

| Алгоритм | Время (мс) | Пикселей |
|:--------------------------------------|:-------------|:----------|
| Пошаговый | 0.0870 | 149 |
| ЦДА | 2.3890 | 149 |
| Брезенхем (линия) | 0.0853 | 149 |
| Брезенхем (окружность) | 0.2335 | 396 |
| Кастл-Питвей | 0.0840 | 149 |
| Алгоритм Ву | 0.1903 | 296 |

**Вывод**:
*   **Брезенхем (линия)** и **Кастл-Питвей** на данных входных параметрах показали практически идентичную и наилучшую производительность среди всех алгоритмов для растеризации отрезков.
*   **Алгоритм ЦДА** демонстрирует аномально низкую производительность. **Причиной этого являются отладочные I/O-операции (`print()`) внутри основного цикла алгоритма.** Эти операции занимают на порядки больше времени, чем сами математические вычисления, что делает замер некорректным для сравнения чистоты алгоритма. Без этих операций его производительность была бы сравнима с Пошаговым алгоритмом.
*   **Алгоритм Ву** работает медленнее, чем базовые не-сглаживающие алгоритмы. Это ожидаемо, так как он выполняет больше вычислений с плавающей точкой для определения интенсивности двух пикселей на каждом шаге.
*   **Брезенхем для окружности** остается высокоэффективным, генерируя большое количество пикселей за приемлемое время, что подтверждает пользу использования симметрии.

## Реализация

Все алгоритмы и пользовательский интерфейс реализованы в одном файле `main.py`.

Алгоритмы реализованы как отдельные функции, принимающие на вход координаты и возвращающие список пикселей:
*   `step_by_step_line(x1, y1, x2, y2)` → `list[tuple[int, int]]`
*   `dda_line(x1, y1, x2, y2)` → `list[tuple[int, int]]`
*   `bresenham_line(x0, y0, x1, y1)` → `list[tuple[int, int]]`
*   `bresenham_circle(xc, yc, r)` → `list[tuple[int, int]]`
*   `castle_pitteway(x1, y1, x2, y2)` → `list[tuple[int, int]]`
*   `wu_antialiasing_line(x1, y1, x2, y2)` → `list[tuple[int, int, float]]` (с интенсивностью)

## UI

Интерфейс приложения реализован с помощью библиотеки **Streamlit**.
*   **Боковая панель**: Используется для выбора алгоритма из списка и ввода параметров (координаты начала/конца отрезка, центр и радиус окружности). Также на панели находится ползунок для управления пропорциями графика.
*   **Основная область**:
    *   Отображает метрики производительности: время выполнения в миллисекундах и общее количество сгенерированных пикселей.
    *   Визуализирует результат работы алгоритма на графике `matplotlib`. График содержит координатные оси, сетку и подписи. Для сравнения, "идеальный" отрезок или окружность отрисовываются пунктирной линией.
    *   График автоматически масштабируется, чтобы вместить всю сгенерированную фигуру.

**Привязка координат**: Целочисленные координаты, сгенерированные алгоритмами, соответствуют **центрам пикселей** в дискретной сетке. На визуализации это показано с помощью квадратных маркеров, центрированных на пересечениях линий сетки.

## Пример вычислений

### Брезенхем (линия): (2, 3) → (8, 6)

1.  **Инициализация:**
    *   `dx = 8 - 2 = 6`
    *   `dy = 6 - 3 = 3`
    *   `x = 2`, `y = 3`
    *   `p = 2*dy - dx = 2*3 - 6 = 0` (используем целочисленный параметр решения `p`)

2.  **Итерации:**
    *   **Шаг 1:** Выводим `(2, 3)`. `p = 0`. Так как `p >= 0`, `y++` (y=4), `p = p + 2*dy - 2*dx = 0 + 6 - 12 = -6`. `x++` (x=3).
    *   **Шаг 2:** Выводим `(3, 4)`. `p = -6`. Так как `p < 0`, `y` не меняется, `p = p + 2*dy = -6 + 6 = 0`. `x++` (x=4).
    *   **Шаг 3:** Выводим `(4, 4)`. `p = 0`. Так как `p >= 0`, `y++` (y=5), `p = p + 2*dy - 2*dx = 0 + 6 - 12 = -6`. `x++` (x=5).
    *   **Шаг 4:** Выводим `(5, 5)`. `p = -6`. Так как `p < 0`, `y` не меняется, `p = p + 2*dy = -6 + 6 = 0`. `x++` (x=6).
    *   **Шаг 5:** Выводим `(6, 5)`. `p = 0`. Так как `p >= 0`, `y++` (y=6), `p = p + 2*dy - 2*dx = 0 + 6 - 12 = -6`. `x++` (x=7).
    *   **Шаг 6:** Выводим `(7, 6)`. `p = -6`. Так как `p < 0`, `y` не меняется, `p = p + 2*dy = -6 + 6 = 0`. `x++` (x=8).
    *   **Шаг 7:** Выводим `(8, 6)`. Цикл завершен.

**Результат**: `(2,3), (3,4), (4,4), (5,5), (6,5), (7,6), (8,6)`.

## Запуск

1.  Установить необходимые библиотеки:
    ```bash
    pip install streamlit matplotlib numpy
    ```
2.  Сохранить код в файл `main.py`.
3.  Выполнить в терминале команду:
    ```bash
    streamlit run main.py
    ```
